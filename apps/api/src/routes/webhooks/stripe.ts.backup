import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import Stripe from 'stripe';
import { StripeService } from '../../services/StripeService';
import { getPlanByStripePrice } from '../../config/plans';

const router = Router();
const prisma = new PrismaClient();

// Initialize Stripe service
const stripeService = new StripeService(
  process.env.STRIPE_SECRET_KEY || '',
  prisma
);

/**
 * POST /api/webhooks/stripe
 * Handle Stripe webhook events
 * 
 * IMPORTANT: This endpoint must use raw body parsing, not JSON parsing
 */
router.post('/stripe', async (req: Request, res: Response) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;

  if (!sig || !webhookSecret) {
    console.error('Missing signature or webhook secret');
    return res.status(400).send('Webhook Error: Missing signature or secret');
  }

  let event: Stripe.Event;

  try {
    // Verify webhook signature
    event = stripeService.verifyWebhookSignature(
      req.body,
      sig as string,
      webhookSecret
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err);
    return res.status(400).send(`Webhook Error: ${err instanceof Error ? err.message : 'Unknown error'}`);
  }

  console.log(`Received Stripe webhook event: ${event.type}`);

  try {
    // Handle the event
    switch (event.type) {
      case 'checkout.session.completed':
        await handleCheckoutSessionCompleted(event.data.object as Stripe.Checkout.Session);
        break;

      case 'invoice.paid':
        await handleInvoicePaid(event.data.object as Stripe.Invoice);
        break;

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;

      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object as Stripe.Subscription);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    res.json({ received: true });
  } catch (error) {
    console.error('Error processing webhook:', error);
    res.status(500).json({ error: 'Webhook processing failed' });
  }
});

/**
 * Handle checkout.session.completed event
 * Update tenant subscription when payment is successful
 */
async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  console.log('Processing checkout.session.completed:', session.id);

  const tenantId = session.metadata?.tenantId;
  if (!tenantId) {
    console.error('No tenant ID in session metadata');
    return;
  }

  // Get the subscription
  const subscriptionId = session.subscription as string;
  if (!subscriptionId) {
    console.error('No subscription ID in session');
    return;
  }

  const subscription = await stripeService.getSubscription(subscriptionId);
  const priceId = subscription.items.data[0]?.price.id;
  const plan = getPlanByStripePrice(priceId);

  // Update tenant with subscription details
  await prisma.tenant.update({
    where: { id: tenantId },
    data: {
      stripeCustomerId: session.customer as string,
      stripeSubscriptionId: subscriptionId,
      subscriptionStatus: 'active',
      currentPlanId: plan?.id || 'free',
      subscriptionEndDate: new Date((subscription as any).current_period_end * 1000),
    },
  });

  console.log(`Tenant ${tenantId} subscription activated`);
}

/**
 * Handle invoice.paid event
 * Renew subscription and sync invoice to database
 */
async function handleInvoicePaid(invoice: Stripe.Invoice) {
  console.log('Processing invoice.paid:', invoice.id);

  // Sync invoice to database
  await stripeService.syncInvoiceToDatabase(invoice);

  // If this is a subscription invoice, ensure tenant status is active
  if ((invoice as any).subscription) {
    const subscription = await stripeService.getSubscription((invoice as any).subscription as string);
    const tenantId = subscription.metadata?.tenantId;

    if (tenantId) {
      const priceId = subscription.items.data[0]?.price.id;
      const plan = getPlanByStripePrice(priceId);

      await prisma.tenant.update({
        where: { id: tenantId },
        data: {
          subscriptionStatus: 'active',
          currentPlanId: plan?.id || 'free',
          subscriptionEndDate: new Date((subscription as any).current_period_end * 1000),
        },
      });

      console.log(`Tenant ${tenantId} subscription renewed`);
    }
  }
}

/**
 * Handle invoice.payment_failed event
 * Suspend tenant access when payment fails
 */
async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  console.log('Processing invoice.payment_failed:', invoice.id);

  // Sync invoice to database
  await stripeService.syncInvoiceToDatabase(invoice);

  // If this is a subscription invoice, mark tenant as past_due
  if ((invoice as any).subscription) {
    const subscription = await stripeService.getSubscription((invoice as any).subscription as string);
    const tenantId = subscription.metadata?.tenantId;

    if (tenantId) {
      await prisma.tenant.update({
        where: { id: tenantId },
        data: {
          subscriptionStatus: 'past_due',
        },
      });

      console.log(`Tenant ${tenantId} marked as past_due due to payment failure`);

      // TODO: Send email notification to tenant
      // TODO: Consider suspending access after grace period
    }
  }
}

/**
 * Handle customer.subscription.updated event
 * Handle plan changes, cancellations, renewals
 */
async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  console.log('Processing customer.subscription.updated:', subscription.id);

  const tenantId = subscription.metadata?.tenantId;
  if (!tenantId) {
    console.error('No tenant ID in subscription metadata');
    return;
  }

  const priceId = subscription.items.data[0]?.price.id;
  const plan = getPlanByStripePrice(priceId);

  // Update tenant subscription details
  const updateData: any = {
    subscriptionStatus: subscription.status,
    subscriptionEndDate: new Date((subscription as any).current_period_end * 1000),
  };

  // If subscription is active or trialing, update the plan
  if (subscription.status === 'active' || subscription.status === 'trialing') {
    updateData.currentPlanId = plan?.id || 'free';
  }

  // If subscription is canceled, prepare for downgrade
  if (subscription.cancel_at_period_end) {
    updateData.subscriptionStatus = 'canceling';
  }

  await prisma.tenant.update({
    where: { id: tenantId },
    data: updateData,
  });

  console.log(`Tenant ${tenantId} subscription updated to ${subscription.status}`);
}

/**
 * Handle customer.subscription.deleted event
 * Downgrade tenant to free plan when subscription is canceled
 */
async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  console.log('Processing customer.subscription.deleted:', subscription.id);

  const tenantId = subscription.metadata?.tenantId;
  if (!tenantId) {
    console.error('No tenant ID in subscription metadata');
    return;
  }

  // Downgrade tenant to free plan
  await prisma.tenant.update({
    where: { id: tenantId },
    data: {
      subscriptionStatus: 'canceled',
      currentPlanId: 'free',
      stripeSubscriptionId: null,
      subscriptionEndDate: new Date(),
    },
  });

  console.log(`Tenant ${tenantId} subscription canceled, downgraded to free plan`);

  // TODO: Send email notification
  // TODO: Clean up resources if needed (e.g., archive old data)
}

/**
 * Handle customer.subscription.created event
 * Track new subscription creation
 */
async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  console.log('Processing customer.subscription.created:', subscription.id);

  const tenantId = subscription.metadata?.tenantId;
  if (!tenantId) {
    console.error('No tenant ID in subscription metadata');
    return;
  }

  // This is usually handled by checkout.session.completed
  // but we log it here for audit purposes
  console.log(`New subscription created for tenant ${tenantId}`);
}

export default router;
