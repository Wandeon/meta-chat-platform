// Prisma schema for meta-chat-platform

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// ============= Tenant & Configuration =============

model Tenant {
  id        String   @id @default(cuid())
  name      String
  apiKey    String   @unique
  settings  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  enabled   Boolean  @default(true)

  channels      Channel[]
  conversations Conversation[]
  documents     Document[]
  webhooks      Webhook[]
  events        Event[]
  secrets       TenantSecret[]

  @@index([apiKey])
  @@map("tenants")
}

model Channel {
  id        String   @id @default(cuid())
  tenantId  String
  type      String // whatsapp, messenger, webchat
  config    Json // Channel-specific credentials
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  secrets ChannelSecret[]

  @@unique([tenantId, type])
  @@index([tenantId, enabled])
  @@map("channels")
}

// ============= Conversations & Messages =============

model Conversation {
  id          String   @id @default(cuid())
  tenantId    String
  channelType String // whatsapp, messenger, webchat
  externalId  String // Platform-specific conversation ID
  userId      String // Phone number, PSID, or user ID
  status      String   @default("active") // active, assigned_human, closed
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastMessageAt DateTime @default(now())

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([tenantId, channelType, externalId])
  @@index([tenantId, status])
  @@index([tenantId, userId])
  @@index([lastMessageAt])
  @@map("conversations")
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  externalId     String? // Platform-specific message ID (wamid, mid)
  direction      String // inbound, outbound
  from           String
  type           String // text, image, audio, video, document, location
  content        Json
  metadata       Json     @default("{}")
  timestamp      DateTime @default(now())
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, timestamp])
  @@index([externalId])
  @@map("messages")
}

// ============= RAG / Knowledge Base =============

model Document {
  id        String   @id @default(cuid())
  tenantId  String
  filename  String
  mimeType  String
  size      Int
  path      String // Storage path
  status    String   @default("pending") // pending, processing, ready, failed
  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  chunks Chunk[]

  @@index([tenantId, status])
  @@map("documents")
}

model Chunk {
  id         String                        @id @default(cuid())
  documentId String
  content    String                        @db.Text
  embedding  Unsupported("vector(1536)")?
  metadata   Json                          @default("{}")
  position   Int // Order within document
  createdAt  DateTime                      @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("chunks")
}

// ============= Webhooks & Events =============

model Webhook {
  id        String   @id @default(cuid())
  tenantId  String
  url       String
  events    String[] // Array of event types to subscribe to
  headers   Json     @default("{}") // Custom headers
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, enabled])
  @@map("webhooks")
}

model Event {
  id        String   @id @default(cuid())
  tenantId  String
  type      String
  data      Json
  timestamp DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, type, timestamp])
  @@index([timestamp])
  @@map("events")
}

model TenantSecret {
  id         String   @id @default(cuid())
  tenantId   String
  name       String
  keyId      String
  ciphertext String
  iv         String
  authTag    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, name])
  @@index([keyId])
  @@map("tenant_secrets")
}

model ChannelSecret {
  id         String   @id @default(cuid())
  channelId  String
  keyId      String
  ciphertext String
  iv         String
  authTag    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([keyId])
  @@map("channel_secrets")
}

// ============= Analytics & Logs =============

model ApiLog {
  id         String   @id @default(cuid())
  tenantId   String?
  method     String
  path       String
  statusCode Int
  duration   Int // milliseconds
  ip         String?
  userAgent  String?
  error      String?
  timestamp  DateTime @default(now())

  @@index([tenantId, timestamp])
  @@index([timestamp])
  @@map("api_logs")
}
