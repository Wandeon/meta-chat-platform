// Prisma schema for meta-chat-platform

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector]
}

// ============= Tenant & Configuration =============

model Tenant {
  id        String   @id @default(cuid())
  name      String
  settings  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  enabled      Boolean  @default(true)
  widgetConfig Json     @default("{}")  @map("widget_config")
  
  // Stripe Billing Fields
  stripeCustomerId     String?   @map("stripe_customer_id")
  stripeSubscriptionId String?   @map("stripe_subscription_id")
  subscriptionStatus   String    @default("free") @map("subscription_status")
  currentPlanId        String    @default("free") @map("current_plan_id")
  subscriptionEndDate  DateTime? @map("subscription_end_date")

  channels      Channel[]
  conversations Conversation[]
  documents     Document[]
  webhooks      Webhook[]
  events        Event[]
  secrets       TenantSecret[]
  apiKeys       TenantApiKey[]
  messages      Message[]
  chunks        Chunk[]
  invoices      Invoice[]
  usageTracking UsageTracking[]
  analyticsDaily  AnalyticsDaily[]
  messageMetrics  MessageMetrics[]
  widgetAnalytics WidgetAnalytics[]

  @@index([stripeCustomerId], map: "idx_tenants_stripe_customer_id")
  @@index([stripeSubscriptionId], map: "idx_tenants_stripe_subscription_id")
  @@index([subscriptionStatus], map: "idx_tenants_subscription_status")
  @@map("tenants")
}

model Channel {
  id        String   @id @default(cuid())
  tenantId  String
  type      String // whatsapp, messenger, webchat
  config    Json // Channel-specific credentials
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant  Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  secrets ChannelSecret[]

  @@unique([tenantId, type])
  @@index([tenantId, enabled])
  @@map("channels")
}

// ============= Conversations & Messages =============

model Conversation {
  id          String   @id @default(cuid())
  tenantId    String
  channelType String // whatsapp, messenger, webchat
  externalId  String // Platform-specific conversation ID
  userId      String // Phone number, PSID, or user ID
  status      String   @default("active") // active, assigned_human, closed
  metadata    Json     @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  lastMessageAt DateTime @default(now())

  tenant   Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  messages Message[]
  messageMetrics MessageMetrics[]

  @@unique([tenantId, channelType, externalId])
  @@index([tenantId, status])
  @@index([tenantId, userId])
  @@index([lastMessageAt])
  @@map("conversations")
}

model Message {
  id             String   @default(cuid())
  tenantId       String
  conversationId String
  externalId     String? // Platform-specific message ID (wamid, mid)
  direction      String // inbound, outbound
  from           String
  type           String // text, image, audio, video, document, location
  content        Json
  metadata       Json     @default("{}")
  timestamp      DateTime @default(now())
  createdAt      DateTime @default(now())

  tenant       Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@id([id, timestamp])
  @@index([id])
  @@index([tenantId, conversationId])
  @@index([conversationId, timestamp])
  @@index([externalId])
  @@map("messages")
}

// ============= RAG / Knowledge Base =============

model Document {
  id        String   @id @default(cuid())
  tenantId  String
  filename  String
  mimeType  String
  size      Int
  path      String // Storage path
  checksum  String // SHA-256 checksum of the stored file
  storageProvider String @default("local") // Storage backend identifier
  version   Int      @default(1) // Incremented on every re-upload
  status    String   @default("pending") // pending, processing, ready, failed, stale
  metadata  Json     @default("{}")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  chunks Chunk[]

  @@index([tenantId, status])
  @@index([tenantId, checksum])
  @@map("documents")
}

model Chunk {
  id         String                        @id @default(cuid())
  tenantId   String
  documentId String
  content    String                        @db.Text
  embedding  Unsupported("vector(1024)")?  // mxbai-embed-large produces 1024-dim vectors
  metadata   Json                          @default("{}")
  position   Int // Order within document
  createdAt  DateTime                      @default(now())

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([tenantId, documentId])
  @@index([documentId])
  // Backed by an IVFFlat index created via SQL migration for pgvector performance
  @@index([embedding], map: "chunks_embedding_ivfflat_idx")
  @@map("chunks")
}

// ============= Webhooks & Events =============

model Webhook {
  id        String   @id @default(cuid())
  tenantId  String
  url       String
  events    String[] // Array of event types to subscribe to
  headers   Json     @default("{}") // Custom headers
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, enabled])
  @@map("webhooks")
}

model Event {
  id        String   @id @default(cuid())
  tenantId  String
  type      String
  data      Json
  timestamp DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, type, timestamp])
  @@index([timestamp])
  @@map("events")
}

model TenantSecret {
  id         String   @id @default(cuid())
  tenantId   String
  name       String
  keyId      String
  ciphertext String
  iv         String
  authTag    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, name])
  @@index([keyId])
  @@map("tenant_secrets")
}

model ChannelSecret {
  id         String   @id @default(cuid())
  channelId  String
  keyId      String
  ciphertext String
  iv         String
  authTag    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  channel Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  @@unique([channelId])
  @@index([keyId])
  @@map("channel_secrets")
}

// ============= Billing & Subscriptions =============

model Invoice {
  id                 Int      @id @default(autoincrement())
  tenantId           String   @map("tenant_id")
  stripeInvoiceId    String   @unique @map("stripe_invoice_id")
  amountPaid         Int      @map("amount_paid")
  currency           String   @default("eur")
  status             String
  invoicePdf         String?  @map("invoice_pdf")
  hostedInvoiceUrl   String?  @map("hosted_invoice_url")
  periodStart        DateTime? @map("period_start")
  periodEnd          DateTime? @map("period_end")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @default(now()) @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId], map: "idx_invoices_tenant_id")
  @@index([stripeInvoiceId], map: "idx_invoices_stripe_invoice_id")
  @@index([createdAt(sort: Desc)], map: "idx_invoices_created_at")
  @@map("invoices")
}

model UsageTracking {
  id                  Int      @id @default(autoincrement())
  tenantId            String   @map("tenant_id")
  periodStart         DateTime @map("period_start")
  periodEnd           DateTime @map("period_end")
  conversationsCount  Int      @default(0) @map("conversations_count")
  documentsCount      Int      @default(0) @map("documents_count")
  teamMembersCount    Int      @default(0) @map("team_members_count")
  messagesCount       Int      @default(0) @map("messages_count")
  apiCallsCount       Int      @default(0) @map("api_calls_count")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @default(now()) @updatedAt @map("updated_at")

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, periodStart], map: "idx_usage_tracking_tenant_period")
  @@index([tenantId], map: "idx_usage_tracking_tenant_id")
  @@index([tenantId, periodStart, periodEnd], map: "idx_usage_tracking_period")
  @@map("usage_tracking")
}

// ============= Analytics & Logs =============

enum AdminKeyStatus {
  active
  disabled
  revoked
}

model AdminKey {
  id             String          @id @default(cuid())
  name           String
  hashedSecret   String
  status         AdminKeyStatus  @default(active)
  metadata       Json?
  expiresAt      DateTime?
  lastUsedAt     DateTime?
  rotatedAt      DateTime?
  rotatedBy      String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  createdBy      String?
  revokedAt      DateTime?
  revokedBy      String?

  auditLogs AdminAuditLog[]

  @@unique([name])
  @@index([status])
  @@index([expiresAt])
  @@map("admin_keys")
}

model AdminAuditLog {
  id          String   @id @default(cuid())
  adminKeyId  String?
  actorId     String?
  actorType   String
  action      String
  target      String?
  description String?
  metadata    Json?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())

  adminKey AdminKey? @relation(fields: [adminKeyId], references: [id], onDelete: SetNull)

  @@index([adminKeyId, createdAt])
  @@index([action, createdAt])
  @@map("admin_audit_logs")
}

model ApiLog {
  id         String   @default(cuid())
  tenantId   String?
  method     String
  path       String
  statusCode Int
  duration   Int // milliseconds
  ip         String?
  userAgent  String?
  error      String?
  timestamp  DateTime @default(now())

  @@id([id, timestamp])
  @@index([id])
  @@index([tenantId, timestamp])
  @@index([timestamp])
  @@map("api_logs")
}

// ============= Authentication & Access Control =============

model TenantApiKey {
  id                 String   @id @default(cuid())
  tenantId           String
  label              String?
  prefix             String
  hash               String
  salt               String
  lastFour           String
  active             Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  lastUsedAt         DateTime?
  expiresAt          DateTime?
  rotatedAt          DateTime?
  rotationTokenHash  String?
  rotationTokenSalt  String?
  rotationIssuedAt   DateTime?
  rotationExpiresAt  DateTime?

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId, active])
  @@index([prefix])
  @@unique([tenantId, label])
  @@map("tenant_api_keys")
}

model AdminUser {
  id            String             @id @default(cuid())
  email         String             @unique
  name          String?
  password      String?
  emailVerified Boolean            @default(false) @map("email_verified")
  role          AdminRole          @default(STANDARD)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  apiKeys       AdminApiKey[]
  verificationTokens VerificationToken[]

  @@map("admin_users")
}

model AdminApiKey {
  id                 String   @id @default(cuid())
  adminId            String
  label              String?
  prefix             String
  hash               String
  salt               String
  lastFour           String
  active             Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  lastUsedAt         DateTime?
  expiresAt          DateTime?
  rotatedAt          DateTime?
  rotationTokenHash  String?
  rotationTokenSalt  String?
  rotationIssuedAt   DateTime?
  rotationExpiresAt  DateTime?

  admin AdminUser @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId, active])
  @@index([prefix])
  @@unique([adminId, label])
  @@map("admin_api_keys")
}

enum AdminRole {
  SUPER
  STANDARD
}


model VerificationToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  adminId   String   @map("admin_id")
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  admin AdminUser @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([adminId])
  @@map("verification_tokens")
}

// ============= MCP (Model Context Protocol) Servers =============

model McpServer {
  id           String   @id @default(cuid())
  name         String   @unique
  description  String?
  command      String   // e.g., "npx", "node", "python"
  args         Json     @default("[]") // Command arguments as array
  requiredEnv  Json     @default("[]") // Required env var names (array of strings)
  enabled      Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("mcp_servers")
}
